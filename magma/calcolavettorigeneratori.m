/* Script per calcolare i vettori generatori
legge i calcoli da fare dal file dataFile
scrive in outputPath/processId.csv
*/

load "magma/segnaturenc.m";
load "magma/rappresentazioni.m";
load "magma/generatorisferici.m";

if not assigned processId then error "variable processId should be assigned to unique string"; end if;
if not assigned dataFile then error "variable dataFile should point to a valid data file"; end if;
if not assigned outputPath then error "variable outputPath should point to a directory to contain the output"; end if;
if not assigned memory then error "variable memory should indicate how many GB to use"; end if;

//come SmallGroup, ma ritorna un record di tipo _FormatoGruppo
_SmallGroupAsRecord:=function(ordine,progressivo)
	G:=SmallGroup(ordine,progressivo);
	return rec<FormatoGruppo| d:=ordine, progressivoGruppo:=progressivo, gruppo:=G>;
end function;

GeneratoriAbelianizzato:=function(G)
	gruppo:=G;
	if Type(gruppo) eq GrpPerm then gruppo:=FPGroup(gruppo); end if;
	return AbelianQuotientInvariants(gruppo);
end function;


//exclude the case where the abelianization cannot be generated by r-1 elements and the case where the lcm of r-1 elements in M is not a multiple of some abelian invariant.
CannotGenerateAbelianization:=function(M,invariants)
	if #invariants ge #M then return true; end if;
	if IsEmpty(invariants) then return false; end if;	//skip the test for perfect groups
	last:=invariants[#invariants];
	M_as_set:={x: x in M};
	if not IsDivisibleBy(Lcm(M_as_set),last) then return true; end if;
	for x in M_as_set do		
		if Multiplicity(M,x) eq 1 and not IsDivisibleBy(Lcm(Exclude(M_as_set,x)),last) then return true; end if;
	end for;
	return false;
end function;

CasoDaIncludere:=function(G, M)
//se il gruppo è ciclico, i controesempi a Coleman-Oort sono noti da
//Moonen, Special subvarieties arising from families of cyclic covers of the projective line. Documenta Mathematica 15 (2010): 793–819.
//in ogni caso se ci interessasse il caso ciclico bisognerebbe modificare anche il calcolo delle segnature
	if (#M ge 5) and IsCyclic(G`gruppo) then return false,"ciclico"; end if;
//se r=4 e il gruppo abeliano, i controesempi a Coleman-Oort sono noti da
//Mohajer-Zuo, Journal of Pure and Applied Algebra 222 (2018) 931–949.
	if  ( #M eq 4) and IsAbelian(G`gruppo) then return false,"abeliano"; end if;
//se non esistono elementi degli ordini giusti inutile lanciare il calcolo
	orders:={Order(g): g in G`gruppo};
	if exists {m : m in M | m notin orders} then return false,"ordini sbagliati"; end if;
  g:=Integers() ! Genere(M,G`d);
// if there exists an element with order > 4(g-1) then either r=3 or g=2, G=Z/6, (2,2,3,3).
//R.S. Kulkarni. Riemann surfaces admitting large automorphism groups, In Extremal Riemann surfaces (San Francisco, CA, 1995), Contemporary Mathematics, 201, pages 63–79, AMS, 1997.
	if g gt 2 and exists {o: o in orders | o gt 4*(g-1)} then return false,"Kulkarni-Wiman"; end if;
	invariants:=GeneratoriAbelianizzato(G`gruppo); 
	if # [x: x in invariants | IsEven(x)] ge 4  then return false,"(Z_2)^4"; end if;
	if CannotGenerateAbelianization(M,invariants) then return false,"abelianization"; end if;
 	return true;
end function;

_FormatoRecordParametri:=recformat< d: Integers(), progressivoGruppo: Integers(), M : SeqEnum>;

LeggiRiga:=function(line)
	result:=rec<_FormatoRecordParametri|>;
	components:=Split(line,";");
	if #components ne 3 then error "Each line in datafile should have the form d;n;[m_1,...,m_r]", components; end if;
	result`d:=StringToInteger(components[1]);
	result`progressivoGruppo:=StringToInteger(components[2]);
	result`M:=eval(components[3]);
	if ExtendedType(result`M) ne SeqEnum[RngIntElt] then error "Each line in datafile should have the form d;n;[m_1,...,m_r], with the m_i integers", result`M; end if;
	return result;
end function;

ESCLUSO_STRING:="I";

ScriviSuFileOutput:=procedure(riga,outputPath)
	Write(outputPath cat "/" cat Sprint(processId) cat ".csv",riga);
end procedure;

ScriviRiga:=procedure(parametri, tempoUtilizzato, generatori,outputPath)
	primaparte:=[* parametri`d, parametri`progressivoGruppo, parametri`M,MBUsedAndTimeSinceLastReset(tempoUtilizzato),VERSION *];
	riga:= FrapponiSeparatore(primaparte,";") cat ";{" cat FrapponiSeparatore(generatori,":") cat "}";
	ScriviSuFileOutput(riga,outputPath);
end procedure;

CalcolaESalvaVettoriGeneratoriDaRiga:=procedure(parametri,outputPath)
	local tempoUtilizzato;
	ResetTimeAndMemoryUsage(~tempoUtilizzato);	
  G:=_SmallGroupAsRecord(parametri`d,parametri`progressivoGruppo);
  daincludere,motivoDiEsclusione:=CasoDaIncludere(G,parametri`M);
	if daincludere then
		rappresentanti:=SetToSequence(FindAllComponents(parametri`M,G));
		ScriviRiga(parametri,tempoUtilizzato,rappresentanti,outputPath);
	else 
		ScriviRiga(parametri,tempoUtilizzato,[ESCLUSO_STRING, motivoDiEsclusione],outputPath);
	end if;
end procedure;


CalcolaESalvaVettoriGeneratoriDaFile:=procedure(fileName,outputPath)
	file:=Open(fileName,"r");
	line:=Gets(file);
	while not IsEof(line) do
		CalcolaESalvaVettoriGeneratoriDaRiga(LeggiRiga(line),outputPath);
		line:=Gets(file);
	end while;
end procedure;


SetMemoryLimit(StringToInteger(memory)*1024*1024*1024);
SetQuitOnError(true);
SetColumns(1024);

CalcolaESalvaVettoriGeneratoriDaFile(dataFile,outputPath);

quit;
